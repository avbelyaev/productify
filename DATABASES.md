## Базы данных

Поскольку я пишу то в контексте тестового задания, то предполагается, что работаем мы с реляционной базой (РСУБД == Реляционная система управления базами данных, RDBMS == .. management system).
В качестве базы можно выбрать (по убыванию удобства):
1. PostgreSQL (самая продвинутая, одна из самых популярных, минус - оч медленная по сравнению с остальными)
2. MySQL (самая популярная, разворачивается пальыем левой ноги, бесплатная, хотя и разрабатывается Oracle'ом)
3. SQLite (база данных в виде одного файлика (а может и вообще без ничего работать - напрямую из памяти), крайне простая, но из-за этого оч ограниченная поддержка SQL. зато ее удобно передавать кому-нибудь, т.к. вся база в одном файлике)
4. MS SQL Server (выбирают те, кто может платить, ибо она полностью платная для коммерческих целей. используется свой язык Transact-SQL (T-SQL))
5. Oracle (сложно запустить локально, платная, быстрая, страшная, тот самый "кровавый энтерпрайз")
6. csv, txt файлик
7. MS Excel + Access
8. одинарный листочек в линейку
9. держать все в голове
10. SyBase (магаз)

Так или иначе, базу легче всего развернуть в докере (я думаю, иного и не предполагается, а докер подразумевается). Для того можно использовать docker-compose.yml файлик с таким описанием:

```yaml
version: '3.1'

services:
  db:
    image: postgres:11
    environment:
      POSTGRES_DB: maryblack
      POSTGRES_USER: maryblack
      POSTGRES_PASSWORD: maryblack
    ports:
      - 5432:5432
```

Стартует база командой `docker-compose up`. КОманда `docker-compose down` останавливает контейнер. Команда `docker-compose rm` удаляет внутренности контейнера. 

База стартанет на :5432. Точно такого же вида композ-файлики есть для mysql, ms sql, и других. Для sqlite, очевидно, никкакой докер не нужен.

Так вот, к делу. Из приложения нам надо как-то достучаться до базы. Есть 2 принципиально разных подхода к кверингу (query) баз данных. Сейчас на примере java/python попытаюсь рассказать чем они отличаются.

# Plain old SQL

Классический способ работы с базами данных - через старые добрые SQL-запросы. Ведь в конце концов сервер базы данных принимает именно такие простые текстовые запросы типа "sect * from ...". 
Поэтому, писать такие запросы, можно, очевидно, не только из всяких PLSQL-developer'ов, PGadmin'ов и прочих IDE, но и "из кода".

Вот как выглядит простейший select из питона в MySQL:

```python
import mysql.connector
from mysql.connector import Error

try:
    connection = mysql.connector.connect(host='localhost', database='mary', user='mary', password='mary')
    cursor = connection.cursor()
    cursor.execute("select * from Goods")
    rows = cursor.fetchall()

    for row in rows:
        print("Id = ", row[0], )
        print("Name = ", row[1])
        print("Price  = ", row[2])

except Error as e:
    print("Error reading data", e)
    
finally:
    connection.close()
    cursor.close()
```

Что здесь происходит:
- создается объект `connection`, представляющий из себя "соедение с БД"
- в рамках соединения `connection` открывается курсор в базу данных
    - Т.к. мы заранее не всегда знаем, сколько данных могло заквериться, то все данные база нам сразу не вернет (представь что вернулся миллиард строк),
и чтение данных в таком случае организуется построчно. Курсор указывает на строку данных и после чтения передвигается к следующей строке).
- с помощью созданного нами курсора мы хотим прочитать товары из таблицы `Goods` и, собсна, выполняем запрос `select * from Goods`
- как было сказано выше, из курсора данные читаются построчно. Но мы, зная, что данных немного, можем попросить сразу все данные и для того делаем `cursor.fetchall()`
    - если мы ожидаем один результат, то делаем `cursor.fetchone()`
- после этого в `rows` у нас лежит список закверенных объектов
    - как ты понимаешь, код на питоне понятия не имеет, что там за данные и для него это тупо набор строк. А то, что в `row[1]` лежит название товара, это уже наша забота.
    - кажется, если в запрос есть алиасы (типа `select count(*) as cnt`), то можно доставать значения из строки по тим алиасам (типа `row['cnt']`), но надо уточнить синтаксис
- код выше проще запустить в дебаге и глянуть как выглядит объект `cursor` и `rows`, сразу станет понятнее

Важно:
- в работе может произойти ошибка (разрыв соединения или еще что) и в конце надо всегда иметь блок finally, который выполнится независимо ни от чего
    - в даннмо случае надо обязательно закрыть соединения базой и закрыть курсор. Зачем? 
        - Базе никто не скажет, что мы дальше не будем работать с ней и она со своей сторны будет поддерживать и соединение и курсор и ждать нас, как Хатико. Кол-во и тех и других всегда ограничено, так что если мы забудем это сделать 100 раз, то на 101й раз мы к базе уже не подключимся
        
Важно так же отметить, что `connection` предсталяет из себя интерфейс (в терминах ООП) к базе данных и значит, меняя его реализацию (здесь мы брали `mysql.connector.connect(...)`) нам не придется менять остальную логику. 
То есть, если заменить строку, где создается подключение, то мы сможем работать хоть с PG, хоть с MSSQL, хоть с Oracle, ибо остальной код агностичен к базе данных. 

Так вот, это классический и самый простой способ работы с базами данных. ЕГо преподают во всех курсах (скорее по разработке) и о нем знают все новички. Проще и нагляднее такой работы - не придумаешь. 

Чтобы не быть голословным насчет того, что такой способ работы - классика, приведу пример на Java:

```java
Connection conn = DriverManager.getConnection("jdbc:postgresql://localhost:5432/mary?user=mary&password=mary");
try {
    PreparedStatement st = conn.prepareStatement("SELECT price as prc FROM Goods");
    ResultSet rs = st.executeQuery();
    while (rs.next())
    {
        System.out.println(rs.getString("prc"));
    }
    
} catch ( Exception e ) {
    System.exit(0);
    
} finally {
    rs.close();
    st.close();
}
```

Из плюсов:
- Таким способом можно выполнить **любой** запрос к БД, ведь по сути это то, что происходит под капотом в твоем PLSQL-developer'е каждый день.
    - вместо `"select * from Goods"` может быть хоть `"insert into Goods values (1, 'toothbrush', 14.88)"` или даже `"create table Foo ( ID int primary key, ...`
- ты полностью контролируешь процесс

Из минусов:
- давольно много лишнего кода, чтобы выполнить такой простой запрос
- это error-prone way (путь к ошибкам), т.к. ты можешь банально пропустить где-то пробел или точку с запятой
- ты сама вручную должна заниматься маппингом той пачки строкв нормлаьнные объекты, с которыми можно работать в питоне
- PLSQL, PG/PLSQL и T-SQL местами заметно отличаются и ты должна сама менять запросы под конкретные базы 
- не всем нравится (и не все могут) писать на голом SQL

---

# ORM

Так вот, люди думали над этими минусами ("что мы как лохи постоянно эти селекты пишем а потом сами эти строки маппим в объекты?") и решили автоматизировать работу с SQL.
Так появился ORM - Object Relational Mapping (маппинг объекта на реляцию == отображение объекта в сущность в реляционной базе данных). 

Раньше ты бы написала что-то вроде:
```python
statement = "INSERT INTO films (title, director, year) VALUES ('Doctor Strange', 'Scott Derrickson', '2016')"  
conn.execute(statement)
```

а сейчас напишешь
```python
doctor_strange = Film("Doctor Strange", "Scott Derrickson", "2016")  
session.add(doctor_strange)
```

И чтобы выбрать все фильмы из таблицы, надо будет лишь сделать
```python
films = session.query(Film)  
for film in films:  
    print(film.title)
```

ORM это абстрактная технолгия маппинга объектов на реляцию. 
Самая популярная реализация ORM в питоне - библиотека SQL-Alchemy и Django-ORM. Второе работает вокруг джангии - это отдельная вселенная, так что остановимся на первом.
Примеры выше и ниже написаны как раз на "алхимии"


Но для того, чтобы такая ~магия~ алхимия работала, надо хорошо подготовиться:
```python
db = create_engine("postgres://admin:qwerty@localhost:5432/films")  
Base = declarative_base()

class Film(Base):  
    __tablename__ = 'films'
    title = Column(String, primary_key=True)
    director = Column(String)
    year = Column(String)
  
base.metadata.create_all(db)
session = Session(bind=db)
```

Что здесь происходит:
- как всегда, все начинается со строки подключения - она меняется от базы к базе, но так или иначе именно она говорит нам как и куда подключаться
- далее мы хотим, чтобы ORM сам за нас создал таблицу в БД. Да-да, мы настолько обленились.
    - можешь глянуть [вики-учебник](https://ru.wikibooks.org/wiki/SQLAlchemy) - там написано что значит декларативный способ описания и какие еще есть способы.
    - но если в двух словах, то это базовый класс, всех наследников которого ORM будет считать сущностями, и сгенерит под каждый дочерний класс таблицу
    - если стало интересно, как именно он это сделает, то [внизу](#рефлексия) я описал, как эта магия на самом деле работает
- собсна, мы описываем нашего наследника от `base` - сущность `Film`
    - имя таблицы будет `films`
    - будут 3 колонки, все строковые, title - PK
- далее как раз происходит магия (если прочитала сноску, то уже не магия) - мы просим создать за нас все таблицы в БД
- затем создается та штука, которая автоматизирует весь процесс - сессия `Session`. Это она будет за нас открывать и зкарывать содинения, курсоры, транзакции, мапитоь объекты и тд.

ПОсле всего этого мы можем творить в рамках "сессии" все что хотим. [Внизу](#unit-of-work) я написал как оно работает под капотом. 
```python
# Мы можем создать новую запись в нашей таблице
doctor_strange = Film(title="Doctor Strange", director="Scott Derrickson", year="2016")  
session.add(doctor_strange)  
session.commit()

# обновить запись (выполнить UPDATE films set blabla where blabla)
doctor_strange.title = "Some2016Film"  
session.commit()

# или удалить
session.delete(doctor_strange)  
session.commit()
```

При этом после каждого изменения, лучше всегда сообщать, что мол мы закончили, чтобы ORM не держал открытые транзакции и тд. Так просто безопаснее и надежнее.


Из плюсов:
- Переносимость: ORM-движок берет на себя различия между базами (как ты помнишь, банальные алиасы где-то пишутся `select foo as bar, count (*) as cnt`, где-то `select foo bar, count(*) cnt` и еще море тонкостей диалектов SQL'ей)
- сам открывает и закрывает соединения, курсоры, транзакции и тд
- исходя из названия, сам занимается маппингом "пачки строк" в нормальные java/python-объекты
- может быть быстрее, т.к. не ходит на каждый чих в базу, а имеет кэш (опять же см. ниже, как работает UOW)
- можно вообще не знать синтаксиса SQL, но не уверен что это плюс

Из минусов:
- сложнее настраивается
    - из коробки у тебя меньше контроля, и ты можешь не подозревать, что на самом деле происходит
    - внезапно оказывается, что ORM конфигурируется через XML (хаха, 2020) или тонну аннотаций в коде
- запросы никто не оптимизирует и они реально тупые и топорные.
    - но ты уже используешь ORM и на чистом SQL тебе больше никто писать не даст, иначе магия не сработает.
    

Тогда такой запрос:
```sql
SELECT * FROM orders JOIN (
  SELECT customer_id, max(order_date) AS last_order_date FROM order GROUP BY customer_id
) AS last_orders
ON orders.customer_id = last_orders.customer_id
ORDER BY last_order_date DESC, orders.order_date DESC
```
придется переписыватть вот в такой треш:
```python
last_orders = db.session.query(
    Order.customer_id, db.func.max(Order.order_date).label('last_order_date')
).group_by(Order.customer_id).subquery()
query = Order.query.join(
    last_orders, Order.customer_id == last_orders.c.customer_id
).order_by(last_orders.c.last_order_date.desc(), Order.order_date.desc())
```

- Вот как выглядит foreign key в случае ORM. взял из [документации](https://docs.sqlalchemy.org/en/13/orm/basic_relationships.html#one-to-many):
```python
class Parent(Base):
    __tablename__ = 'parent'
    id = Column(Integer, primary_key=True)
    children = relationship("Child")

class Child(Base):
    __tablename__ = 'child'
    id = Column(Integer, primary_key=True)
    parent_id = Column(Integer, ForeignKey('parent.id'))
```
- но если на сущностях нет прямой связи, заджоинить их нельзя. то есть есть parent, child, grandchild. В Parent не указан нигде grandchild, а в grandchild не укзана Parent - ВСЕ! ты их не заджоинишь. никак. вообщею приедтся доп таблицу создавать и мудрить через нее.


---
 
Для любознательных

## Рефлексия

```python
class Film(Base):  
    __tablename__ = 'films'
    id = Column(BigIntegerID, primary_key=True, autoincrement=True)
    title = Column(String)
    director = Column(String)
    year = Column("year_of_release", Integer)
```

Мы уже поняли, что т.к. `Film наследует от base`, то Film с т.з. ORM, является таблицей.
Давай поймем, как SQL alchemy строит таблицу по описанию класса: Есть 2 вида такой магии.

1.Рефлексия (reflect - отражать) - то способ подсмотреть за программой во время ее выполнения. 
В питоне, кажется, есть такая штука, как metadata - всевозможнная техническая информация об объекте, доступная в рантайме, то есть непосредственно во время выполнения программы. 
Например, ты можешь глянуть (и получить как набор строк) все поля объекта.
Точно так же можешь получить все методы объекта. В питоне нет ничего приватного, значит ты можешь все. 

В том числе
- вытащить значение `films` из приватного технического поля `__table__`
- вытащить названия статических полей: `id, title, director, year`
    - каждое статическое поле - объект класса `Column`, у которого есть какие-то параметры, которые задают столбец таблицы
    - у всех столбцов названия берутся исзодя из названия поля, а у `year` оно оверрайдится названием `"year_of_release"`.
- у того класса нет методов, но в питоне в рантайме мы можем сами доавбить объекту метод, ведь то всего лишь функция
    - ORM неявно добавляет от себя конструктор и какие-то еще методы

Таким образом, из полученной инфы Alchemy создает обычную строку запроса:
```sql
create table films 
(
  id bigint primary key identity,
  title text,
  director text,
  year_of_release int
);
```

и затем выполняет ее. Да, да, ORM - это о том, как генерить такие SQL-строчки с умным видом :)

Теперь мы можем создать таким образом строку таблицы, создав объект в питоне и добавив его в сессию:
```python 
strange = Film(123, "dr strange", "john doe", 2016)
session.add(strange)
```

2. А что там у джавистов? Джавовый ORM (Hibernate) работает более явно. Т.к. джава компилится, то часть данных в райнтайме будет отличаться от того, что написано в коде. Для этого в джаве есть аннотации - это явные указания компилятору. В коде ниже - приватные поля будет сложно прочесть в рантайме и их имена будут невидны (сотрутся). А вот аннотации останутся - и ORM сможет достать названия полей. И сгенерит такой же SQL-запрос.

```java
@Entity(table = "films")
public class Film {

    @ID(autoincrement = true)
    private String id; 
    
    @Column(name = "title")
    private String title;
    
    ...
}
```

Так что никакой магии нет - есть только суровый парсинг либо строк, либо объектов/классов в рантайме


## Unit-of-work

Как же работает под капотом Session. Работает оно по паттерну Unit-of-work (единица работы). Это паттерн (шаблон проектирования. Ты слышала о шаблонах "singleton", "facade" и мб каких еще),
который дозирует работу с чем либо. В нашем случае - работу с базой. Очевидно, на каждый чих ходить в базу - затратно, ведь несущественных запросов может быть миллион.

Паттер UOW (в случае ORM) решает проблему так: вот наша сессия подкчилась к базе данных. Вот мы сделали в первый раз select и закверили что-то. Этот набор данныз UOW сохраняет в память. 
- Предположим, так лежит та самая строка с фильмом про доктора стренжа.
- Вот мы захотели обновить год выпуска фильма и написать туда 2020. 
- Вместо того, чтобы делать `UPDATE films set year_of_release=2020 ...`, он делает то же самое, но в памяти:
    - берет объект, который отвечает за ту строку и меняет дату релиза в нем на `year_of_release=2020`.
- Вот мы захотели изменить и название.
    - берем тот же объект (в памяти) и меняем в нем еще и название
- но ту хобана! нас попросили достать все фильмы, выпущенные в 2020
    - но как быть? ведь в базе-то по-прежнему стоит 2016 - мы же туда ни разу не вносили изменения - мы меняли все в памяти
    - и вот тут ORM замечает, что этот запрос пересекается с тем, что находится у нас в памяти
        - тогда он втайне от нас делает, грубо говоря, `Select * from films`
        - смотрит что пришло из базы, и что есть у него в памяти (куда он сохранял все наши изменения)
        - вычисляет разницу между объектами
        - генерирует SQL-запрос, чтобы привести все в консистентное состояние. 
             - Например `UPDATE films set year_of_release=2020, name='mr strange' WHERE name='dr strange'`
             - То есть одним махом применяет все накопившиеся изменения
        - выполняет UPDATE-запрос
    - теперь в базе консистетные данные
    - и теперь ORM выполяет тот запрос, который нам был нужен
    
    
Как ты понимаешь, весь это процесс нетривиален. Еще нетривиальнее он становится, когда у нас 100500 потоков и все ходят в базу и все параллельно что-то обновляют. 

Как итог, ORM становится бутылочным горлышком, и не может никого другого пустить в базу, ибо сам ее занял и контролирует. 
Как итог, он сковывает тебя по рукам и ногам. 

Это удобно на страте (раз, два, и мы сходили в базу без SQL), но в какой-то момент от ORM отказываются (выкидывают полностью) и наичнают руками писать старые добрые SQL-запросы
