# Продуктивизация модели

### V1

Я, как пользователь, могу зайти в приложение и ввести текст в единственное текстовое поле.
После нажатия кнопки "Analyze", в интерфейсе я вижу значение тональности введенного текста, либо сообщение об ошибке в остальных случаях.

Ожидаемый результат:
- фронтенд с текстовым полем, кнопкой и показом результата классификации
- бекенд, обрабатывающий запросы от фронта
- классификатор, выполняющий саму логику классификации
- все работает локально в браузере

#### Классификатор

Разработку будем вести снизу вверх. См подробнее [внизу](виды-разработки).

Начинаем разработку с самого нижнего слоя. У нас в самом низу - классификатор.

Надо выделить интерфейс классификатора, он же API. Подробнее см [внизу](api)

Если я сторонний разработчик, то мне не важно, как внутри работает твоя модель и уж тем более я не знаю,
как ее пиклить и какие нумпаевские методы дергать. Поэтому я бы хотел импользовать ее как билиотеку, котрая предосталяла бы API типа такого:
```python
t = TonalityAnalyzer()
tone1 = t.analyzeTone(text='Ужасно смешной фильм', lang='ru')
tone2 = t.analyzeTone(text='the movie was fcking awesome!', lang='en')
```

Но! т.к. модельку делаем мы сами, то мы знаем как ее дергать, поэтому такую обертку над моделькой можно сейчас не городить.
Главное, чтобы она делала свою работу (принимала строку и возвращала результат классификации), а уж в каком виде - сейчас не важно.



### Бекенд

Бекенд отвечает за бизнес-логику приложения и связывает пользовательскую часть с классификатором.

Предлагается реализовать HTTP API со следующим контрактом:

- Определение тональности переданного текста 
  - POST `/api/tonality/analyze` - это называют **endpoint** - то есть "конечная точка" соединения, т.е. место, куда приходит запрос от клиента
  - Принимает json вида:
```json
{
  "text": <строка, текст для анализа>
}
```
  - Тональность опеределена успешно: 200 OK и json вида: 
```json
{
  "tone": <float, число обозначающее тональность>
}
```

Бекенд должен предоставлять описанный выше HTTP API и тогда с ним можно будет взаимодейстовать с помощь curl, бразуера, python-requests и тд.

На что обратить внимание: 
- Прежде чем делать фронт, надо понять что бек работает. 
  - Как запустить бекенд (питоновское приложение по сути) без зеленой кнопки пайчарма?
- Как локально дернуть API curl’ом?
  - раньше мы делали что-то типа `curl --data ... localhost:8080/do/smth` и передавали заголовки и сам json 
- Убедиться что запросы приходящие на бекенд отображаются в stdout 
  - иначе будет сложно отлаживать работу, не понимая, дошел запрос до бека или потерялся по пути
  
  
### Фронтенд

С т.з. UI выглядит максимально просто:
- текстовое поле для ввода ссобщения
- кнопка "Analyze", по нажатию которой текст отправляется на анализ тональности
- блок, показывающий тональность введенного сообщения (например, числом от 0 до 1) 

Технически максмально прост:
- файл с разметкой и описанными выше тремя ключевыми элементами страницы
- файл со стилями, чтобы смотрелось красиво
- файл с js-кодом, отвечающий за отправку запроса, получение ответа и отображение ответа на странице. 
  - чтобы отправить запрос, надо считать введенный в текстовое поле текст, обернуть его в json и отправить (с соблюдением всех заголвоков и всего, что мы отлаживали curl'ом)
  - в ответе надо принять json, расправсить его поле `tone` и вывести значение в какой-либо элемент на странице (google "add text to div")

На что обратить внимание:
1. как отправляются запросы на бекенд?
  - веб работает аснихронно и запрос тоже должен быть асинхронным (синхронный запрос выполняется синхронно, т.е. блокрирует выполнение остальных команд, пока
  не будет завершена текущая). самый простой способ - XHR - см [здесь](https://learn.javascript.ru/xmlhttprequest)
1. куда уходят запросы? 
  - они должны уходить на host:port где разернут бекенд
  - запросы так же видны во вкладке "networks" в dev tools (chrome F12)
1. Настройка CORS. 
  - cURL отправляет запросы AS-IS. Браузер работает более деликатно
  - Браузер, прежде чем что-либо куда-либо слать, сначала спросит, готов ли сервер принять такой запрос. 
  - Такой предварительный запрос называется preflight request. 
  - Надо уметь его принять на беке и верно ответить, иначе браузер не будет выполнять "основной запрос"
  - Ошибки CORS как правило заметны в dev tools (вкладки "network" и "console"), chrome F12
1. наконец, как запустить фронтенд, чтобы его можно было открыть в браузере по адресу `http://localhost` 
  - мы раздавали фронт с помощью встроенного питоновского веб-сервера (`python3 -m http.server ...`)


## Справка

#### API

*API*  - application programming interface - прикладной интерфейс разработки. 

интерфейс в терминах ООП, т.е. набор методов, видимых снаружи.
Интерфейс холодильника - "открыть дверцу", "заркыть дверцу". 
Интервейс машины - "завести/остановить двигатель", "поехать вперед/назад", "повернуть направо/налево".
Интерфейс классификатора - "fit", "predict".
Т.е. это минимальный набор команд(методов), с помощью которого можно взаимодействовать с объектом.

Так же это принято называть *"публичным контрактом"*. Контракт потому, что ты сможешь эффективно работать с объектом, 
если соблюдаешь все его условия (вызываешь с правильными аргументами, обрабатывашь ошибки и т.д.).


#### Трехзвенная архитектура

aka *3-tier* architecture. приложение представляют в виде пирога из 3х слоев. 

Сверху вниз идут:
- клиентская часть (обычно в виде пользовательского GUI - graphical user interface)
- бекенд (слой с бизнес-логикой)
- уроввень данных (источник правды для всего приложения)   

![o](tier3.jpeg)


#### Виды разработки

Ознакомься сначала с [трехзвенкой](трехзвенная-архитектура).

Разработка бывает 2х таких видов.

**Снизу-вверх** - сначала проектируют модель данных (схему бд, сущности, таблицы, ограничения и тд), потом над ней выстраивают бекенд. 
Получившийся бекенд обычно называют CRUD-бекендом (create-read-update-delete, post-get-put-delete, insert-select-update-delete) - 
то есть он предоствляет минимальный набор примитивных операций. 
Соответственно у бекенда (например, мы управляем учетками сотрудников) получается API в стиле 
- POST `/api/employees` - создать учетку
- GET `/api/employees` - получить список всех учеток
- GET `/api/employees/<id>` - получить учетку по ID
- DELETE `/api/employees/<id>` - удалить учетку
- GET `/api/access` -  получить список доступов
  
Чтобы уволить сотрудника, мы должны залистить список всех учеток, найти нужного сотрудника, достать его ID, сходить, например, в соседний API, которые заблокиурет ему доступы и передать туда ID.
Затем выполнить DELETE `/api/.../123`. Как ты понимаешь, здесь вместо сотрдников можно подставить заказ холодильника, перевод денег и что угодно.

Получается API (и само приложение), которые никакого отношения к бизнесу не имеют - такого рода проекты делают на галерах типа luxoft, айти, mc'kinsey, т.к. это делается быстрее и дешевле всего - но пользователься этим невозможно.
  
**Сверху-вниз** - разработка от потребностей пользователя. фронтенд и UX ставятся во главу угла (т.к. пользователю не продают json'ы, а продают продукт),
а дальше проектируется бекенд. Модель данных (для БД) - подстраивается под потребности пользователя и в итоге мы имеем API вида
- POST `/api/employees/<id>/deactivate` - который выполнит весь процесс по нажатию одной кнопки.

Получаем приложение в стиле Apple с одной кнопкой "сделать хорошо" - лучший UX







