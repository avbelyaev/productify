# Продуктивизация модели

## Step 1 (baseline)

_примерное время: 3-5 часов_ 

_теги: API, HTTP (TCP/IP, методы, статусы, header'ы), терхзвенная архитектура, REST HTTP API, endpoint (controller), cURL, XHR_

Я, как пользователь, могу зайти в приложение и ввести текст в единственное текстовое поле.
После нажатия кнопки "Analyze", в интерфейсе я вижу значение тональности введенного текста, либо сообщение об ошибке в остальных случаях.

Ожидаемый результат:
- фронтенд с текстовым полем, кнопкой и показом результата классификации
- бекенд, обрабатывающий запросы от фронта
- классификатор, выполняющий саму логику классификации
- все работает локально в браузере

## Классификатор

У нас нет инвесторов или аналитиков, которым надо как можно скорее показать итоговое решение. И у нас нет команды, чтобы параллелить работу. И у нас нет уникального пользовательского опыта, от которого надо отталкиваться. Так что пойдем по-старинке, снизу вверх - от классификаторов и баз данных, а что получится наверху - не так страшно, т.к. проект совсем простой

Начинаем разработку с самого нижнего слоя. У нас в самом низу - классификатор.

Надо выделить интерфейс классификатора, он же API. Подробнее см [REFERENCE#api](REFERENCE.md)

Если я сторонний разработчик, то мне не важно, как внутри работает твоя модель и уж тем более я не знаю,
как ее пиклить и какие нумпаевские методы дергать. Поэтому я бы хотел импользовать ее как билиотеку, котрая предосталяла бы API типа такого:
```python
t = TonalityAnalyzer()
tone1 = t.analyzeTone(text='Ужасно смешной фильм', lang='ru')
tone2 = t.analyzeTone(text='the movie was fcking awesome!', lang='en')
```

Но! т.к. модельку делаем мы сами, то мы знаем как ее дергать, поэтому такую обертку над моделькой можно сейчас не городить.
Главное, чтобы она делала свою работу (принимала строку и возвращала результат классификации), а уж в каком виде - сейчас не важно.



## Бекенд

Бекенд отвечает за бизнес-логику приложения и связывает пользовательскую часть с классификатором.

Предлагается реализовать API со следующим контрактом:

- Определение тональности переданного текста 
    - POST `/api/tonality/analyze` - это называют **endpoint** (или контроллер) - то есть "конечная точка" соединения, т.е. место, куда приходит запрос от клиента
    - Принимает json вида:
```json
{
  "text": <строка, текст для анализа>
}
```
    - Тональность опеределена успешно: 200 OK и json вида: 
```json
{
  "tone": <float, число обозначающее тональность, от 0.0 до 1.0, где 0.0 - негативная оценка, 1.0 - позитивная>
}
```

Мы хотим спроектировать API. API это вещь абстрактная, т.е. это просто о том, как с объектом взаимодействовать, но мысли никто
читать не умеет, а объект, с которым мы хотим работать находится где-то на сервере в интернете, так что нам нужно что-то физическое, 
с помощью чего можно организовать это взаимодействие. В данном случае самая физическая вещь, что у нас есть - протокол HTTP - hypertext transfer protocol. 

Про то, как работает HTTP смотри [REFERENCE#http](REFERENCE.md)
 
- Помнишь, мы в классификаторе хотели сделать удобное API над моделькой? 
    - Так вот, там мы реалзиовывали API с помощью языка python, т.к. объект, с которым мы хотели работатьт был питоновским объектом ( в терминах ООП).
    - получаем python API
- Сейчас у нас "объект" находится где-то на сервере в недрах интернета 
    - И его API надо реализовывать так, чтобы мы смогли с ним работать через интренет
    - получаем HTTP API
    - HTTP API обычно отвечает "требованиям" REST. Про REST см [REFERENCE#rest](REFERENCE.md)

Бекенд должен предоставлять описанный выше **REST HTTP API** и тогда с ним можно будет взаимодейстовать с помощь curl, бразуера, python-requests и здравого смысла.

### Задания 
0. Реализовать описанный выше HTTP API на Flask'е
1. Прежде чем делать фронт, надо понять что бек работает. 
    - Как запустить бекенд без пайчарма?
2. Как локально дернуть API curl’ом?
    - раньше мы делали что-то типа `curl --data ... localhost:8080/do/smth` и передавали заголовки и сам json 
3. Убедиться что запросы приходящие на бекенд отображаются в stdout 
    - иначе будет сложно отлаживать работу, не понимая, дошел запрос до бека или потерялся в дебрях сетей AWS
4. _доп_ На каждый приходящий запрос писать в лог (для начала `print`), кто его отправил, т.е. User agent отправителя
    - можно будет увидеть, что вот пришел запрос от хрома, вот от curl'а, а вот - от веб-краулера
  
### Контрольные вопросы
1. В чем отличие HTTP методов POST, PUT, HEAD?
2. Каким заголовком мы можем "попросить" сервер вернуть нам в качестве ответа НЕ json, а, например, xml или html?
3. Набросать HTTP API интернет магазина (просмотр товаров, добавление в корзину, оформление заказа) - хотя бы 3-4 ендпоинта
4. Можно ли удалять документы (пусть документ == пользователь) выполняя GET-запрос `/api/users/<id>`?
5. HTTP не хранит состояние (он не знает что перед запросом Y был запрос X) - как в таком случае сказать серверу, что мы уже встрчались (и логинились) - иначе он каждый раз будет простить нас залогиниться?

  
  
## Фронтенд

UI выглядит максимально просто:
- текстовое поле для ввода ссобщения
- кнопка "Analyze", по нажатию которой текст отправляется на анализ тональности
- блок, показывающий тональность введенного сообщения (например, числом от 0 до 1) 

Технически максмально прост:
- файл с разметкой и описанными выше тремя ключевыми элементами страницы
- файл со стилями, чтобы смотрелось красиво 
    - предложил бы вообще забить на CSS в начале, т.к. на CSS может уйти времени больше чем на весь этот tutorial
- файл с js-кодом, отвечающий за отправку запроса, получение ответа и отображение ответа на странице. 
    - чтобы отправить запрос, надо считать введенный в текстовое поле текст, обернуть его в json и отправить (с соблюдением всех заголвоков и всего, что мы отлаживали curl'ом)
    - в ответе надо принять json, расправсить его поле `tone` и вывести значение в какой-либо элемент на странице (google "add text to div")

### Задания
0. Реализовать фронтенд
1. Реализовать асинхронную отправку запросов
    - веб работает аснихронно и запрос тоже должен быть асинхронным (синхронный запрос выполняется синхронно, т.е. блокрирует выполнение остальных команд, пока
  не будет завершена текущая. Сеть ненадежна и ответ может не прийти никогда - тогда клиент навечно зависнет). 
    - самый простой способ - XHR - см [здесь](https://learn.javascript.ru/xmlhttprequest). (см. также AJAX - async javascript and xml)
2. убедиться, что запросы доходят до бека
    - они должны уходить на host:port где разернут бекенд
    - запросы из браузера так же видны во вкладке "networks" в dev tools (chrome F12)
3. Настройка CORS. 
    - cURL отправляет запросы AS IS, "как есть". Браузер работает более деликатно
    - Браузер, прежде чем что-либо куда-либо слать, сначала спросит, готов ли сервер принять такой запрос. 
    - Такой предварительный запрос называется preflight request. 
    - Надо уметь его принять на беке и верно ответить, иначе браузер не будет выполнять "основной запрос"
    - Ошибки CORS как правило заметны в dev tools (вкладки "network" и "console"), chrome F12
4. наконец, запустить фронтенд, чтобы его можно было открыть в браузере по адресу `http://localhost` 
    - мы раздавали фронт с помощью встроенного питоновского веб-сервера (`python3 -m http.server ...`)
    - настроить правильный порт для разадачи фронтенда
5. _доп_ сделай собственную красивую кнопку с помощью `<div>`
    - Посмотри свойства `hover` и `active` html-элемента и почитай про свойство `onclick=` 
 

### Контрольные вопросы
0. В URL укзаано, что мы идем на `https://google.com`. Но этот путь указывает не на конкретную страницу, а тупо на хост.
    - какой файл сервер по умолчанию будет искать, ведь страничку гугла мы все-таки увидим?
1. Какой порт используется протоколом HTTP по умолчанию? 
    - какой у HTTPS? какой используется протоколом SSH?
2. Какой HTTP статус говорит о том, что документ не найден?
    - за что отвечают статусы 2хх? 3хх? 4хх? 5хх?
3. Можно ли ответить статусом 666 на запрос, например, создания пользователя? 
4. Как почистить куки в хроме?
5. Как удалить дурацкий баннер на Pinterest, который закрывает экран, если ты не залогинен?
    - баннер это точно такой же html-элемент как и все что есть на странице. занчит, он подчиняется тем же законам, что и остальные элементы
    - значит, мы можем "работать" с ним через dev tools и можем вырезать его со страницы :)
6. уметь объяснить что значит каждый тег в начале занятия

---





## Step 2 (раздача фронтенда с бекенда)

![o](img/flask-logo.png)

_примерное время: 1 час_ 

_теги: DNS, резолвинг адресов, статика_

в этой серии мы научимся оперировать приложением, как единым целым и запускать одним процессом

Выше мы сделали бейзлайн нашего приложения, или можно сказать MVP - minimal viable product == минимальную рабочую версию.
Она работает локально, но пришло время дать пользователям доступ к ней. Для этого необходимо сделать ряд изменений в базовой версии.

- Как ты помнишь, сейчас фронтенд запускается отдельным процессом с помощью стандартного питоновского веб-сервера. 
Этот веб-сервер разадет все, что находится в текущей директории (в том числе пресловутый index.html), откуда запущен процесс.
- Бекенд запущен как питоновское приложение
 
Но, как ты понимаешь, это все-таки 2 разных процесса - один раздает фронтенд, другой крутит бекенд.

Действия пользователя:
- Я, как пользователь, открываю твое приложение по адресу `http://maryblack.rocks`
    - Я нахожусь в мск
    - а сервер с приложением крутится где-то на западном побережье америки
- мой браузер делает запрос на хост 1.2.3.4 и порт :80 за стартовой страничкой index.html
    - за то, как `http://maryblack.rocks` резловится в `http://1.2.3.4` отвечает DNS - я тебе о нем говорил. Можно считать, что это map{hostname -> ip}: `DNS["marybcloak"]="1.2.3.4"`
    - на сервере мне отвечает тот питоновский процесс, который сидит на порту :80 - с ним я общаться могу.
    - у меня в браузере в москве открылась страничка с твоим приложением (то есть мне прилетели мои "копии" html,css,js и отрендерили приложение)
    - я ввожу текст и нажимаю кнопку "Analyze". Внимание, вопрос, куда уйдет запрос? 
        - На какой хост:порт? ведь мне нужно достучаться до единственного конкретного сервера в америке!
        - кто его на том хосту:порту примет? подумай, как оно может быть устроено
        - ответы на оба вопроса - чуть ниже
          
вот как работает DNS на картинке по порядку: 

![o](img/dns.jpg)
          
#### на какой хост:порт уйдет запрос?
- существуют _абсолютные_ и _относительные_ адреса - ты это, думаю, знаешь. 
    - абcолютный адрес: `https://maryblack.rocks/models/tonality/index.html?foo=bar`
    - отнсительный: `/foo/bar/baz`. говоря об относительной адресации всегда надо понимать _относительно чего_ идет адресация
    - запрос можно сделать *собрав полный (абсолютный) URL* (ведь нам нужно получить ip-адрес по hostname'у от DNS, но hostname'а в отнсительном адресе нет)
- так вот, в запросах мы раньше явно указывали полный абсолютный URL бека: `http://localhost:5000/api/tonality/analyze` 
- но мы ведь хотим, чтобы со страницы, открытой у меня на компе в мск запрос ушел на сервер в америку, но мы 
    - не всегда знаем адрес сервера (мы не знаем где в конце концов будет крутиться наша страничка, если это огромный сайт/портал типа гугла или Я)
    - мы не хотим хардкодить этот адрес: представь что у нас на странице 100 кнопок - тогда придется 100 раз писать на копках адреса типа `http://foo.com/api/x`, `http://foo.com/api/y` и тд
- умные люди (разработчики браузеров) решили эту проблему конвенионально:
    - если в запросе указан относительный URL (см выше), то он будет резолвиться *относительно текущего сайта*
    - то есть запрос `/new_dir/index.php?r=blah` выполненный со страницы `http://www.foo.com/bar.php`
    - будет зарезолвлен в `http://www.foo.com/new_dir/index.php?r=blah` (т.е. относительно текущего сайта `foo.com`)
    - а конпки, как ты понимаешь, и знать не знают полные URL - на каждой из них написано лишь `/api/x`, `/api/y`, `api/z`
- так вот, в нашем случае запрос `/api/tonality/analyze` пойдет на `http://maryblack.rocks/api/tonality/analyze` и нам при этом не надо указывать ни хост, ни порт.


#### кто его на том хосту:порту примет?
- по-правильному решается это с помощью проксирования запросов (тот самый Nginx)
- запросы так же приходят на один сервер (он и раздает *статику* - статический, редко меняющийся контент, и обслуживает вызовы к API)
- но дальше в зависимости, от типа запроса, в ответ отдается либо статика (html/css/js, картинки, видосики), либо запрос перенаправляется на бекенд. 
    - самое интуитивное правило роутинга: если запрос начианется на `/api/**`, то мы его проксируем, например:
        - Запрос `http://maryblack.rocks/models/tonality` вернет index.html
        - Запрос `http://marycloak.rocks/api/models/tonality` будет запроскирован на бекенд и ответит на него сам бекенд
        
Проксировать умеют все сервера (Apache, Nginx и т.д.), но возиться с ними - это не то, чего мы хотим сейчас 

Поэтому мы можем пойти в другую сторону: сделать так, чтобы наш бекенд одновременно 
- раздавал статику (наши 3 файлика)
- раздавал HTTP API
- занимал при этом только 1 порт

Веб-серверы из коробки умеют раздавать статику. Это решается, как правило, конвенционально: 
- встроенный `pythom -m http.server` раздается текущую директорию
- Nginx раздает папку `var/nginx/html`
- Spring раздает `resources/static`
- Flask раздает `static`

если к этому моменту у тебя возникла путаница в "серверной" терминологии, то [REFERENCE#django-flask](REFERENCE.md) я кратко попытался прояснить это.

### Задание
1. Понять (из доков), что нужно для раздачи статики FLask'ом
    - скорее всгео это какой-то ендпоинт (контроллер), который скажет flask'у, что теперь он должен раздавать статику
        - у нас есть ендпоинт `/api/analyze` для бизнес логики, а будет еще один - для раздачи статики
    - гуглится в стиле "flask host static resources" или "flask serve static content"
2. Орагнизовать проект так, чтобы фронтенд был собран в той папке, которую будет раздавать flask 
3. запутсить *только бекенд* и убедиться, что фронтенд раздается с бека
    - проверить, что приложение доступно из браузера
    - указать (или убедиться, что указан) правильный адрес для запроса по кнопке "Analyze" и запрос отрабатывает

### Контрольные вопросы
1. уметь объяснить, что значит каждый тег в начале занятия

---





## Step 3 (деплой на AWS)

![o](img/aws_logo_1.png)

_примерное время: 1 час_ 

_теги: AWS, deploy_

К этому моменту наше приложение уже работает как единое целое и не зависит от места расположения сервера (в коде не хардкодятся localhost'ы).
Пришло время открыть его всему миру!

Давным давно Amazon столкнулся с тем, что его информационная система была слишком слаба для обслуживания всех его складов, доставщиков, покупаетелй, продавцов и прочей логистики.
Они отрефакторили свою систему: теперь команды брали чуть-чуть мощностей Amazon'овского парка машин и работали на них. 
И тут они поняли, что получлось нечто большее и "продали" идею Безосу как новый бизнес.

Суть была проста: последнее, чем стартапам, малому и среднему-неайтишному бизнесу, или тебе, хочется заниматься - это возиться с желеязяками, настраивать сеть и поднимать линуксы.
Компании хотят максимально быстро дать людям продукт, а не "нарезать виртуалки". И за нарезку виртуалок, настройку сетей и железа стал отвечать сам Amazon. Так появился AWS.
Концепцию назвали **Infrastructure-as-a-Service (IaaS)**, то есть "инфраструктура в аренду" и **Platform-as-a-Service (PaaS)**, т.е. платформы для запуска приложений, абстрагированная от железа.

Первым продуктом стали виртуальные машины (обычные linux ubunt'ы) - Amazon EC2 (Elastic Compute Cloud) - то есть практически первое "вычислительное облако". 
Elastic - значит, что оно может "растягиваться под потребности" и деньги.

Затем появлись Google Cloud, Microsoft Azure. Потом появлись российкие копии типа Mailru Cloud Solutions и Я.облако, 
но было уже поздно, т.к. Amazon вошел в раш и начал делать все "as-a-Service", то есть БД-as-a-service, hadoop-as-a-service, DNS-as-a-service и тд.

![o](img/aws.png)

С тех пор компании не владеют железом, а арендуют его у Amazon (и строят большие сложные виртуальные системы) и уже инженеры AWS возятся с железяками. 
А самый обльшой и тербовательный клиент AWS - Netflix со своими премьерами stranger things. [здесь](https://theogm.com/2017/09/10/are-you-aligned-with-the-fastest-growing-cloud-platform-on-the-planet/) можно чуть подробнее почитать об этом. Если AWS может выдержать Netflix, то он может выдержать все :)


Так вот, мы тоже не хотим копаться в железе, а хотим арендовать виртуалку (виртуальный сервер, кусок физической машины) в AWS EC2.
Такую машину называют инстансом (EC2 instance). Как ее получить:
- зарегистрироваться во free-tier AWS
- найти среди многочисленных сервисов нужный нам EC2
- EC2 имеет контрольную панель на которй отображаются все имеющиеся у тебя машины
    - instance type - тип машины (кол-во ядер, RAM, сеть и тд)
    - zone - регион, в которм запущена машина
    - public/private DNS - DNS внутри кластера машин, то есть это о том, как достучаться снаружи/извне до твоей тачки
        - как ты помнишь, достучаться можно по hostname'у http://ec2-52-91-34-110.compute-1.amazonaws.com
        - а можно напрямую по IP-адресу `52.91.34.110`, в который резолвится этот hostname

![o](img/ec2.png)

По кнопке "Launch instance" мы заказываем новую машину. Во free-tier'е у тебя может быть максимум одна машина на 1 ядро и 1Гб RAM и 10Гб жесткий диск.
Надо пройти через несколько шагов, чтобы создать машину
- выбрать ОС (лучше всего выбирать ubuntu)
- выбрать тип машины (t2.micro), память, что-то еще. как правило, в каждом пунтке бесплатная опция помечена зеленым шильдиком "free tier"
- сгенерировать пару ключей доступа (на машину сложат публичный ключ, тебе дадут скачать приватный ключ)
- после этого машина запустится и будет доступна по SSH с выданным тебе ключом.
    - тонкий момент: чтобы зайти по SSH, ты указываешь user@host ("user at host"). в данном случае user - `ubuntu`

По умолчанию ради безопасности на машине открыт только порт 22 для SSH. Это значит, что до машины кроме как по SSH достучаться не получится.
Чтобы до машины можно было достучаться другими способами, надо настроить "security groups":
- в консоли EC2 в разделе security groups надо создать "правило" фильтрации трафика
    - правила применяются ко входящему/исходящему трафику: inboud/outbound rules
    - надо создать правило, которое откроет нужный тебе порт (надеюсь, к этому моменты ты уже знакома с портами)
    - после этого, надо применить созданное правило к машине: это делается правым кликом по инстансу (по крайней мере, на момент написания статьи это делалрсь именно так)
    - google "ec2 security groups for web server" 

Процесс выкладки приложения в прод называется **деплоем** (deploy, deployment, развертывание, "накатываем в пятницу"). Часто коверкуют до уродского "раскладка", но суть не меняется:
до деплоя приложение работало локально, а теперь работает на каком-то стенде (test, stage, preprod, prod и тд). 

Если с приложением проблемы, приложение откаывают, т.е. делают **роллбек** (rollback, rollout, откат).
Штатное обновление приложения - редеплой.

### Задание
0. создать EC2-инстанс
1. задеплоить на него приложение
    - для этого, разумеется, надо как-то доставить проект на этот сервер
2. создать security group, который бы позволил достучаться до приложения
    - поскольку security group это "о портах", то надо согласовать порты приложения и порты, которые ты настраиваешь в security group
    - применить security group к инстансу
3. убедиться, что приложение доступно всему миру!
    - лучше всего проверять в режиме инкогнито в браузере, чтобы не было проблем с кешами и прочими настройками браузера в обычном режиме
        - не забывай про dev tools (chrome F12)
    - можно проверить открыв, как хостнейм, так и напрямую IP-адрес в хроме.
    - убедиться, что бизнес-логика работает (кнопка "Analyze")


---

## Step 4 (Docker)

У докера вышла приличная по размерам часть, так что - см [CONTAINERIFY.md](CONTAINERIFY.md)

## Step 4.5 Docker-compose

Как говорится, "а теперь без рук" :)

---

## Step 5 Deploy

Деплой приложения из образа, коль скоро мы уже умеем их собирать

---

## Step 6 CI

Написание тестов, настройка Github Actions/Circle/Travis к проекту. 

Автоматизация тестрования (и сборки образов)

---

## Step X  Backlog

- CD и e2e-тесты. К этому моменту приложение должно уже быть развернуто и ты должна уже мочь обновить версию приложения
- сбор метрик (добавить лайк/дизлайк на фронте, чтобы собирать фидбек о качестве работы)
- База данных - сохранение запросов, логов
- Интеграция с чем-нибудь, например, с гугл-переводчиком чтобы поддерживать ввод на англ языке. То есть модель обучнеа для русского но мы сначала переводим текст. Или с гугл-картинками, чтобы по фану было


