# Продуктивизация модели

## V1 (baseline)

Я, как пользователь, могу зайти в приложение и ввести текст в единственное текстовое поле.
После нажатия кнопки "Analyze", в интерфейсе я вижу значение тональности введенного текста, либо сообщение об ошибке в остальных случаях.

Ожидаемый результат:
- фронтенд с текстовым полем, кнопкой и показом результата классификации
- бекенд, обрабатывающий запросы от фронта
- классификатор, выполняющий саму логику классификации
- все работает локально в браузере

### Классификатор

Разработку будем вести снизу вверх. См подробнее [внизу](#виды-разработки).

Начинаем разработку с самого нижнего слоя. У нас в самом низу - классификатор.

Надо выделить интерфейс классификатора, он же API. Подробнее см [внизу](#api)

Если я сторонний разработчик, то мне не важно, как внутри работает твоя модель и уж тем более я не знаю,
как ее пиклить и какие нумпаевские методы дергать. Поэтому я бы хотел импользовать ее как билиотеку, котрая предосталяла бы API типа такого:
```python
t = TonalityAnalyzer()
tone1 = t.analyzeTone(text='Ужасно смешной фильм', lang='ru')
tone2 = t.analyzeTone(text='the movie was fcking awesome!', lang='en')
```

Но! т.к. модельку делаем мы сами, то мы знаем как ее дергать, поэтому такую обертку над моделькой можно сейчас не городить.
Главное, чтобы она делала свою работу (принимала строку и возвращала результат классификации), а уж в каком виде - сейчас не важно.



### Бекенд

Бекенд отвечает за бизнес-логику приложения и связывает пользовательскую часть с классификатором.

Предлагается реализовать API со следующим контрактом:

- Определение тональности переданного текста 
    - POST `/api/tonality/analyze` - это называют **endpoint** (или контроллер) - то есть "конечная точка" соединения, т.е. место, куда приходит запрос от клиента
    - Принимает json вида:
```json
{
  "text": <строка, текст для анализа>
}
```
    - Тональность опеределена успешно: 200 OK и json вида: 
```json
{
  "tone": <float, число обозначающее тональность>
}
```

Мы хотим спроектировать API. API это вещь абстрактная, т.е. это просто о том, как с объектом взаимодействовать, но мысли никто
читать не умеет, а объект, с которым мы хотим работать находится где-то на сервере в интернете, так что нам нужно что-то физическое, 
с помощью чего можно организовать это взаимодействие. В данном случае самая физическая вещь, что у нас есть - протокол HTTP - hypertext transfer protocol. 

КОгда создавался интернет, достаточно было уметь передавать 1 и 0 между компьтерами по проводам. Но с развитивем интернета понадобилось 
передавать кучу сложной информации (музыка, видео) и передавать надежно (если потеряется пара кадров - не страшно, если потерять сообщение вк - страшно).
Тогда начали усложнять решение (которое изначально умело только 1 и 0 передавать) и надстраивать сверху все новые и новые протоколы. 
Так появился "стек TCP/IP". В самом низу - протокол передачи 1 и 0 с помощью перемены напряежения в проводе (называется "манчестерский код"). 
На самой его верхушке лежит HTTP - текстовый протокол взаимодействия систем по сети интернет. 
 
- Помнишь, мы в классификаторе хотели сделать удобное API над моделькой? 
    - Так вот, там мы реалзиовывали API с помощью языка python, т.к. объект, с которым мы хотели работатьт был питоновским объектом ( в терминах ООП).
    - получаем python API
- Сейчас у нас "объект" находится где-то на сервере в недрах интернета 
    - И его API надо реализовывать так, чтобы мы смогли с ним работать через интренет
    - получаем HTTP API
    - HTTP API обычно отвечает "требованиям" REST. Про REST см [внизу](#rest)

Бекенд должен предоставлять описанный выше **REST HTTP API** и тогда с ним можно будет взаимодейстовать с помощь curl, бразуера, python-requests и здравого смысла.

##### Задания 
0. Реализовать описанный выше HTTP API на Flask'е
1. Прежде чем делать фронт, надо понять что бек работает. 
    - Как запустить бекенд без пайчарма?
2. Как локально дернуть API curl’ом?
    - раньше мы делали что-то типа `curl --data ... localhost:8080/do/smth` и передавали заголовки и сам json 
3. Убедиться что запросы приходящие на бекенд отображаются в stdout 
    - иначе будет сложно отлаживать работу, не понимая, дошел запрос до бека или потерялся в дебрях сетей AWS
4. _доп_ На каждый приходящий запрос писать в лог (для начала `print`), кто его отправил, т.е. User agent отправителя
    - можно будет увидеть, что вот пришел запрос от хрома, вот от curl'а, а вот - от веб-краулера
  
##### Контрольные вопросы
1. В чем отличие HTTP методов POST, PUT, HEAD?
2. Каким заголовком мы можем "попросить" сервер вернуть нам в качестве ответа НЕ json, а, например, xml?
3. Набросать HTTP API интернет магазина (просмотр товаров, добавление в корзину, оформление заказа) - хотя бы 3-4 ендпоинта
4. Можно ли удалять документы (условных пользователей) выполняя GET `/api/users/<id>`?
5. HTTP не хранит состояние (он не знает что перед запросом Y был запрос X) - как в таком случае сказать серверу, что мы уже встрчались (и логинились - иначе он каждый раз будет простить нас залогиниться)?

  
  
### Фронтенд

С т.з. UI выглядит максимально просто:
- текстовое поле для ввода ссобщения
- кнопка "Analyze", по нажатию которой текст отправляется на анализ тональности
- блок, показывающий тональность введенного сообщения (например, числом от 0 до 1) 

Технически максмально прост:
- файл с разметкой и описанными выше тремя ключевыми элементами страницы
- файл со стилями, чтобы смотрелось красиво
- файл с js-кодом, отвечающий за отправку запроса, получение ответа и отображение ответа на странице. 
    - чтобы отправить запрос, надо считать введенный в текстовое поле текст, обернуть его в json и отправить (с соблюдением всех заголвоков и всего, что мы отлаживали curl'ом)
    - в ответе надо принять json, расправсить его поле `tone` и вывести значение в какой-либо элемент на странице (google "add text to div")

##### Задания
0. Реализовать фронтенд
1. Реализовать асинхронную отправку запросов
    - веб работает аснихронно и запрос тоже должен быть асинхронным (синхронный запрос выполняется синхронно, т.е. блокрирует выполнение остальных команд, пока
  не будет завершена текущая. Сеть ненадежна и ответ может не прийти никогда - тогда клиент навечно зависнет). 
    - самый простой способ - XHR - см [здесь](https://learn.javascript.ru/xmlhttprequest)
2. убедится, что запросы доходят до бека
    - они должны уходить на host:port где разернут бекенд
    - запросы из браузера так же видны во вкладке "networks" в dev tools (chrome F12)
3. Настройка CORS. 
    - cURL отправляет запросы AS IS, "как есть". Браузер работает более деликатно
    - Браузер, прежде чем что-либо куда-либо слать, сначала спросит, готов ли сервер принять такой запрос. 
    - Такой предварительный запрос называется preflight request. 
    - Надо уметь его принять на беке и верно ответить, иначе браузер не будет выполнять "основной запрос"
    - Ошибки CORS как правило заметны в dev tools (вкладки "network" и "console"), chrome F12
4. наконец, запустить фронтенд, чтобы его можно было открыть в браузере по адресу `http://localhost` 
    - мы раздавали фронт с помощью встроенного питоновского веб-сервера (`python3 -m http.server ...`)
    - настроить правильный порт для разадачи фронтенда
5. _доп_ сделай собственную красивую кнопку с помощью `<div>`
    - Посмотри свойства `hover` и `active` html-элемента и почитай про свойство `onclick=` 
 

##### Контрольные вопросы
0. В URL укзаано, что мы идем на `https://google.com`. Но этот путь указывает не на конкретную страницу, а тупо на хост.
    - какой файл сервер по умолчанию будет искать, ведь страничку гугла мы все-таки увидим?
1. Какой порт используется протоколом HTTP по умолчанию? 
    - какой у HTTPS? какой используется протоколом SSH?
2. Какой HTTP статус говорит о том, что документ не найден?
    - за что отвечают статусы 2хх? 3хх? 4хх? 5хх?
3. Можно ли ответить статусом 666 на запрос, например, создания пользователя? 
4. Как почистить куки в хроме?
5. Как удалить дурацкий баннер на Pinterest, который закрывает экран, если ты не залогинен?
    - баннер это точно такой же html-элемент как и все что есть на странице. занчит, он подчиняется тем же законам, что и остальные элементы
    - значит, мы можем "работать" с ним через dev tools и можем вырезать его со страницы :)

---

## V2 (раздача фронтенда с бекенда)

_в этой серии мы научимся оперировать приложением, как единым целым и запускать одним процессом

Выше мы сделали бейзлайн нашего приложения, или можно сказать MVP - minimal viable product == минимальную рабочую версию.
Она работает локально, но пришло время дать пользователям доступ к ней. Для этого необходимо сделать ряд изменений в базовой версии.

- Как ты помнишь, сейчас фронтенд запускается отдельным процессом с помощью стандартного питоновского веб-сервера. 
Этот веб-сервер разадет все, что находится в текущей директории (в том числе пресловутый index.html), откуда запущен процесс.
- Бекенд запущен как питоновское приложение
 
Но, как ты понимаешь, это все-таки 2 разных процесса - один раздает фронтенд, другой крутит бекенд.

Действия пользователя:
- Я, как пользователь, открываю твое приложение по адресу `http://maryblack.rocks`
    - Я нахожусь в мск
    - а сервер с приложением крутится где-то на западном побережье америки
- мой браузер делает запрос на хост 1.2.3.4 и порт :80 за стартовой страничкой index.html
    - за то, как `http://maryblack.rocks` резловится в `http://1.2.3.4` отвечает DNS - я тебе о нем говорил. Можно считать, что это map{hostname -> ip}: `m["marybcloak"]="1.2.3.4"`
    - на сервере мне отвечает тот питоновский процесс, который сидит на порту :80 - с ним я общаться могу.
    - у меня в браузере в москве открылась страничка с твоим приложением (то есть мне прилетели мои "копии" html,css,js и отрендерили приложение)
    - я ввожу текст и нажимаю кнопку "Analyze". Внимание, вопрос, куда уйдет запрос? 
        - На какой хост:порт? 
        - кто его на этом хосту:порту примет? подумай, как оно устроено. а ответ - ниже:
          
Ответ:
- питоновский веб-сервер умеет только отдавать статику (html/css/js - "статический" контент, т.к. почти никогда не меняется)
- а Flask'овский бекенд запушен отдельным процессом и вот имеено он занимается анализом текста, т.е. бизнес-логикой и нам хочется достучаться до него
- по-правильному решается это с помощью проксирования запросов (тот самый Nginx): запросы так же приходят на один сервер, но дальше в зависимости, от типа запроса,
в ответ отдается либо страничка (html/css/js), либо запрос перенаправляется на бекенд. 
    - самое интуитивное правило роутинга: если запрос начианется на `/api/**`, то мы его проксируем, например:
        - Запрос `http://maryblack.rocks/models/tonality` вернет index.html
        - Запрос `http://marycloak.rocks/api/models/tonality` будет запроскирован на бекенд и в ответ вернется json от бекенда
        
Возиться с Nginx - это не то, чего мы хотим. 

Поэтому мы можем пойти в другую сторону: сделать так, чтобы наш бекенд одновременно 
- раздавал статику (наши 3 файлика)
- раздавал HTTP API
- занимал при этом только 1 порт

Веб-серверы, коим является и Flask, из коробки умеют это делать. Это решается, как правило, конвенционально: 
- встроенный `pythom -m http.server` раздается текущую директорию
- Nginx раздает папку `./var/nginx/html`
- Java рдздает папку`./assets`
- Flask раздает папку ???. Я не знаю, какую папку он раздает, но делать это он точно умеет

##### Задание
1. Понять (из доков), что нужно для раздачи статики фласком
    - скорее всгео это какой-то ендпоинт (контроллер), который скажет фласку, что теперь он должен еще и раздавать статику
        - у нас есть ендпоинт `/api/analyze` для бизнес логики, а будет еще один - для раздачи статики
    - гуглится в стиле "flask host static resources" или "flask serve static content"
2. Орагнизовать проект так, чтобы фронтенд был собран в той папке, которую будет раздавать flask 
3. запутсить только бекенд и убедиться, что фронтенд раздается с него
    - ф 


## Справка

#### API

*API*  - application programming interface - прикладной интерфейс разработки. 

интерфейс в терминах ООП, т.е. набор методов, видимых снаружи.
Интерфейс холодильника - "открыть дверцу", "заркыть дверцу". 
Интервейс машины - "завести/остановить двигатель", "поехать вперед/назад", "повернуть направо/налево".
Интерфейс классификатора - "fit", "predict".
Т.е. это минимальный набор команд(методов), с помощью которого можно взаимодействовать с объектом.

Так же это принято называть *"публичным контрактом"*. Контракт потому, что ты сможешь эффективно работать с объектом, 
если соблюдаешь все его условия (вызываешь с правильными аргументами, обрабатывашь ошибки и т.д.).


#### REST

REST - REpresentation State Transfer - стиль архитектуры (как правило, веб приложений) для эффективного взаимодействия 
между клиентом и сервером. То, чем оперирует сервер назвается **ресурсами** и REST это о том, как сопоставить
документы этим ресурсам. Чисто технически - это способ проектирования API. 

Есть такое правило, что REST - это когда ты отперируешь "существительными" в организации ресурсов. 

Допустим, мы делаем API для соцсети. Мы можем спроектировать API таким образом
- GET `/api/users` - список всех юзеров
- POST `/api/register` - создать пользователя
- PUT `/api/users/update?userId=123` - обновить пользователя, с ID, например, 123
- POST `/api/friends?userId=123` - получить список друзей пользователя с ID=123

такое API будет работать, но оно будет неочевидным для потребителей (другие приложения, разработчики и т.д. потребляют "API") - 
здесь присутствуют глаголы (`/register`, `/update`) и не используется богаствство протокола HTTP.

REST реализация оперирует всем, как документами:
- GET `/api/users` - список юзеров
- POST `/api/users` + json - создать нового пользователя
- GET `/api/users/<id>` - получить пользователя по ID
- PUT `/api/users/<id>`+ json - обновить информацию о пользователе
- GET `/api/users/<id>/friends` - список друзей пользователя с ID
- GET `/api/users/<id>/albums/<id>` - какой-то альбом пользователя
- DELETE `/api/users/<id>` - удалить пользователя

в данном случае мы используем иерархию, HTTP-методы и заголовки для управления докумнетами. Это более RESTful, но сама по себе
тем глубоко холиварная, т.к. нет никаких стандартов и каждый понимает как хочет.


#### Трехзвенная архитектура

aka *3-tier* architecture. приложение представляют в виде пирога из 3х слоев. 

Сверху вниз идут:
- клиентская часть (обычно в виде пользовательского GUI - graphical user interface)
- бекенд (слой с бизнес-логикой)
- уроввень данных (источник правды для всего приложения)   

![o](tier3.jpeg)


#### Виды разработки

Ознакомься сначала с [трехзвенкой](#трехзвенная-архитектура).

Разработка бывает 2х таких видов.

**Снизу-вверх** - сначала проектируют модель данных (схему бд, сущности, таблицы, ограничения и тд), потом над ней выстраивают бекенд. 
Получившийся бекенд обычно называют CRUD-бекендом (create-read-update-delete, post-get-put-delete, insert-select-update-delete) - 
то есть он предоствляет минимальный набор примитивных операций. 
Соответственно у бекенда (например, мы управляем учетками сотрудников) получается API в стиле 
- POST `/api/employees` - создать учетку
- GET `/api/employees` - получить список всех учеток
- GET `/api/employees/<id>` - получить учетку по ID
- DELETE `/api/employees/<id>` - удалить учетку
- GET `/api/access` -  получить список доступов
  
Чтобы уволить сотрудника, мы должны залистить список всех учеток, найти нужного сотрудника, достать его ID, сходить, например, в соседний API, которые заблокиурет ему доступы и передать туда ID.
Затем выполнить DELETE `/api/.../123`. Как ты понимаешь, здесь вместо сотрдников можно подставить заказ холодильника, перевод денег и что угодно.

Получается API (и само приложение), которые никакого отношения к бизнесу не имеют - такого рода проекты делают на галерах типа luxoft, айти, mc'kinsey, т.к. это делается быстрее и дешевле всего - но пользователься этим невозможно.
  
**Сверху-вниз** - разработка от потребностей пользователя. фронтенд и UX ставятся во главу угла (т.к. пользователю не продают json'ы, а продают продукт),
а дальше проектируется бекенд. Модель данных (для БД) - подстраивается под потребности пользователя и в итоге мы имеем API вида
- POST `/api/employees/<id>/deactivate` - который выполнит весь процесс по нажатию одной кнопки.

Получаем приложение в стиле Apple с одной кнопкой "сделать хорошо" - лучший UX







